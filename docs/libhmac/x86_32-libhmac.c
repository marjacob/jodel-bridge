//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2016 Retargetable Decompiler <info@retdec.com>
//

#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

// ------------------------ Structures ------------------------

struct struct_0 {
    int32_t * e0;
    int32_t e1;
    char e2[4];
    int32_t e3;
    int32_t e4;
};

// ------------------- Function Prototypes --------------------

int32_t client_secret(char * a1);
int32_t function_3d0(void);
int32_t function_444(int32_t result);
int32_t function_470(char * a1);
int32_t function_4a6(int32_t a1);
int32_t function_4d0(void);
void function_4dc(void);
void function_510(void);
int32_t function_685(void);
int32_t get_generated_key(char * a1);
int32_t get_random_key(void);
int32_t Java_com_jodelapp_jodelandroidv3_api_HmacInterceptor_generate(struct struct_0 * a1, int32_t a2);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebp
int32_t g3 = 0; // ebx
int32_t g4 = 0; // edx
int32_t g5 = 0; // esi
int32_t g6 = 0x464c457f;
int32_t g7 = 0x8002000;

// ------------------------ Functions -------------------------

// Address range: 0x3d0 - 0x443
int32_t function_3d0(void) {
    int32_t v1 = function_4d0(); // bp+421
    __cxa_finalize();
    return v1 + 0x1bda;
}

// Address range: 0x444 - 0x46f
int32_t function_444(int32_t result) {
    int32_t v1 = g1; // bp+444
    char * v2 = (char *)v1;
    *v2 = (char)((int32_t)*v2 + v1);
    int32_t v3 = g1; // bp+446
    char * v4 = (char *)v3;
    *v4 = (char)((int32_t)*v4 + v3);
    int32_t v5 = g1; // bp+448
    char * v6 = (char *)v5;
    *v6 = (char)((int32_t)*v6 + v5);
    int32_t v7 = g1;
    char * v8 = (char *)v7;
    *v8 = (char)((int32_t)*v8 + v7);
    int32_t v9 = g1;
    char * v10 = (char *)v9;
    *v10 = (char)((int32_t)*v10 + v9);
    int32_t v11 = g1;
    char * v12 = (char *)v11;
    *v12 = (char)((int32_t)*v12 + v11);
    if (result != 0) {
        // 0x45c
        ((int32_t (*)())result)();
        // branch -> 0x45e
    }
    // 0x45e
    return result;
}

// Address range: 0x470 - 0x4a5
int32_t function_470(char * a1) {
    int32_t v1 = function_4d0(); // bp+471
    return __cxa_atexit((void (*)())(v1 - 38), a1, (char *)(v1 + 0x1b8a));
}

// Address range: 0x4a6 - 0x4cf
int32_t function_4a6(int32_t a1) {
    // 0x4a6
    function_4d0();
    __stack_chk_fail();
    return g5;
}

// Address range: 0x4d0 - 0x4db
int32_t function_4d0(void) {
    // 0x4d0
    int32_t result;
    return result;
}

// Address range: 0x4dc - 0x4df
void function_4dc(void) {
    char * v1 = (char *)g1;
    *v1 = (char)((int32_t)*v1 + g1);
    char * v2 = (char *)g1;
    *v2 = (char)((int32_t)*v2 + g1);
}

// Address range: 0x4e0 - 0x50f
int32_t get_random_key(void) {
    // 0x4e0
    return function_685() + 0x1b3b;
}

// Address range: 0x510 - 0x51f
void function_510(void) {
    char * v1 = (char *)g1;
    *v1 = (char)((int32_t)*v1 + g1);
    char * v2 = (char *)g1;
    *v2 = (char)((int32_t)*v2 + g1);
    char * v3 = (char *)g1;
    *v3 = (char)((int32_t)*v3 + g1);
    char * v4 = (char *)g1;
    *v4 = (char)((int32_t)*v4 + g1);
    char * v5 = (char *)g1;
    *v5 = (char)((int32_t)*v5 + g1);
    char * v6 = (char *)g1;
    *v6 = (char)((int32_t)*v6 + g1);
    char * v7 = (char *)g1;
    *v7 = (char)((int32_t)*v7 + g1);
    char * v8 = (char *)g1;
    *v8 = (char)((int32_t)*v8 + g1);
}

// Address range: 0x520 - 0x57f
int32_t get_generated_key(char * a1) {
    int32_t v1 = function_4d0() + 0x1abd; // ebx
    char * v2 = (char *)get_random_key();
    int32_t v3 = 0; // bp+549
    char v4 = v2[v3]; // bp+543
    *(char *)(v3 + 124 + v1) = a1[v3] ^ v4;
    int32_t v5 = 1; // bp+550
    // branch -> 0x540
    while (v5 != 40) {
        // 0x540
        v3 = v5;
        v4 = v2[v3];
        *(char *)(v3 + 124 + v1) = a1[v3] ^ v4;
        v5++;
        // continue -> 0x540
    }
    // 0x558
    return v1 + 124;
}

// Address range: 0x580 - 0x60f
int32_t client_secret(char * a1) {
    int32_t v1 = g3; // bp+583
    g3 = function_4d0() + 0x1a5b;
    int32_t v2 = get_generated_key((char *)(int32_t)*a1);
    int32_t mem = (int32_t)malloc(g7);
    int32_t v3 = 0;
    // branch -> 0x5c0
    while (true) {
        int32_t v4 = v3 + 1;
        g4 = v4;
        int32_t v5 = 4 * v3 / 4;
        uint32_t v6 = v3 % 4;
        int32_t v7 = v6 ^ 3;
        g1 = v2;
        uint32_t v8 = *(int32_t *)(v5 + v2);
        uint32_t v9 = v6 == 3 ? 0 : 8 * v7;
        *(char *)(v7 + v5 + mem) = (char)(v8 >> v9);
        if (v4 == 40) {
            // 0x5f1
            *(char *)(mem + 40) = 0;
            g3 = v1;
            int32_t v10;
            g2 = v10;
            return mem;
        }
        // after_if_5e4_0.dec_label_pc_5c0_crit_edge
        v3 = g4;
        // branch -> 0x5c0
    }
}

// Address range: 0x610 - 0x684
int32_t Java_com_jodelapp_jodelandroidv3_api_HmacInterceptor_generate(struct struct_0 * a1, int32_t a2) {
    g3 = function_4d0() + 0x19cb;
    g5 = (int32_t)a1;
    int32_t v1 = *(int32_t *)a1;
    g1 = v1;
    int32_t v2 = *(int32_t *)(v1 + 676);
    int32_t v3;
    ((int32_t (*)(int32_t, int32_t, int32_t))v2)((int32_t)*(char *)a1, v3, g6);
    int32_t v4 = *(int32_t *)(*(int32_t *)g5 + 668); // edi
    int32_t result = client_secret((char *)g1);
    ((int32_t (*)(int32_t, int32_t))v4)((int32_t)*(char *)g5, result);
    int32_t v5 = g5;
    int32_t v6 = *(int32_t *)v5;
    g4 = v6;
    g1 = v3;
    int32_t v7 = *(int32_t *)(v6 + 680); // bp+672
    char v8 = *(char *)g2;
    ((int32_t (*)(int32_t, int32_t, int32_t, int32_t))v7)((int32_t)*(char *)v5, v3, (int32_t)v8, 0);
    return result;
}

// Address range: 0x685 - 0x688
int32_t function_685(void) {
    // 0x685
    int32_t result;
    return result;
}

// --------------- Dynamically Linked Functions ---------------

// int __cxa_atexit(void(*func)(void *), void * arg, void * dso_handle);
// void __cxa_finalize(void);
// void __stack_chk_fail(void);
// void * malloc(size_t);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.9)
// Detected functions: 12
// Decompiler release: v2.1.2 (2016-01-27)
// Decompilation date: 2016-04-13 15:12:11
